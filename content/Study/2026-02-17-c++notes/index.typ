#import "../../index.typ": template, tufted
#show: template.with(title: "C++ 八股文查漏补缺")

= C++ 八股文查漏补缺

这里只是把我不知道的或不常用的八股文写进来了，其他我已经会的就不写了#footnote[当前，如果写了那肯定是写全了，而且每一个都经过ai的审核，确保没有遗漏的或不说人话的部分]。所以不能只把我的这个当成背诵文档。从这个网址背的：#link("https://xiaolincoding.com/interview/cpp.html")[C++ 面试题]

感觉背八股文本身就是错的，完全没有必要，可是现在的公司在面试的时候都在问八股，也就只能背了。

== 常量指针与指针常量

文章里写的很复杂，其实核心就两个规则：
+ const 左结合
+ 如果左边没有类型，则右结合

体现：

比如常量指针：`const int * p;` 与 `int const * p`。都是与 int 结合，没有与 `*` 结合，所以指针本身(`*`)是可以更改的，但是指向的值(`int`)无法更改。

而指针常量：`int * const p`：这个与 `*` 结合，所以指针不可以更改，而指向的值可以更改。

这个规则忘记是从哪里看到的了，不过如果我没有记错，应该是从 #link("https://book.douban.com/subject/35863224/")[《C++20高级编程》]中看到的。

== static 的作用

static 可以定义静态变量，静态函数。

=== 改变 全局变量 的作用域

对于全局变量来说，如果没有 static ，则其作用域是*全局作用域*。其他文件可以通过 `extern` 关键字来访问到该文件中定义的全局变量。而如果加上了 `static`，则会将其作用域限制到了*文件作用域*中。此时，其他的文件无法再访问到该全局变量。在这个情况下，即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

未初始化的全局静态变量会被编译器将其默认初始化为0。因为全局静态变量存放在内存的 BSS 段，程序启动时系统会自动将该段所有数据清零。

=== 改变 局部变量 的生命周期

正常来说，一个局部变量会随着其所在作用域的消失而消失，当函数执行结束时，变量会被自动销毁。但是对于静态变量来说，它在程序运行期间只会初始化一次，在程序结束运行时才会销毁。当函数多次调用时，它会保留上一次调用结束时的数值。

=== 更改类的成员变量与成员函数的相关性

在没有定义 static 时，类的成员变量与成员函数都描述的是与一个*对象*的一系列的信息与动作，而加上了 `static` 以后，该描述的是与*类型*相关的信息与动作。此时，不需要定义对象，可以直接通过类来访问静态成员与静态函数。

这里有需要注意的：
+ 类的静态成员函数只能访问静态成员变量与静态成员函数
+ 不可以将静态成员函数定义成虚函数
+ 静态成员变量在类内声明，需要在*类外*定义与初始化。

== Union 联合体

Union 由若干个数据类型不同的数据成员组成。使用时联合体只有一个有效的成员。对联合体不同的成员赋值，会覆盖其他成员的值。其内存分配规则为：其内部所有变量的最大值，按照最大类型的倍数进行分配大小。

比如:

```cpp
typedef union {
    char c[10];
    double d;
} u33;
```

由于这里 double 是8个字节，所以按该类型的倍数分配大小。所以其最终的大小为：24 字节（8 \* 3）。

== volatile

原文说的那些是*完全的错误*。

在 c++中，volatile 正确的使用场景主要有：
+ 内存映射 I/O：在嵌入式开发或驱动开发中，访问硬件寄存器。由于硬件的状态随时会更改，所以必须要求编译器每次都真切的读地址上的值，不可以优化。
+ 信号处理：使用 sig_atomic_t 类型的变量在信号处理函数与主程序之间通信时，需要加 volatile。

=== 为什么是错的？

如果两个线程同时访问同一个非原子变量（且其中一个是写操作），发该操作就是 c++标准中定义的“数据竞争”，这是*未定义行为(UB)*。而编译器的所有的优化性能的操作，都是通过UB来优化的#footnote[只要标准中没有定义，那么编译器就可以做任何的事]。

=== 怎么做才是对的？

在 C++11标准中。如果要实现上述的功能，可以使用：原子变量或锁。

== 为什么一般将析构函数设置为虚函数？

这里原文介绍的比较的浅，但是我也记不清了，所以正好去查一查资料来回忆一下。

为了在使用“基类指针指向派生类对象”并进行 delete 操作时，可以正确触发动态绑定，从而先调用派生类的析构函数，再调用基类的析构函数，防止内存泄漏或资源未释放。

以下是具体的例子：

```cpp
class Base {
public:
    // 假设这里没加 virtual
    ~Base() { cout << "Base dest" << endl; }
};

class Derived : public Base {
public:
    int* data;
    Derived() { data = new int[100]; }
    ~Derived() { 
        delete[] data; 
        cout << "Derived dest" << endl; 
    }
};

int main() {
    Base* ptr = new Derived(); // 基类指针指向派生类对象
    delete ptr;                // 关键点在这里！
}
```

如果没有加`virtual`，那么编译器就会认为这个ptr是一个Base类型的对象。此时就会直接调用 `Base::~Base()` 函数，即：只调用基类的析构函数。如果 `Derived` 中也定义了一些对象，需要依靠析构函数来清除，那么这就会使得内存泄漏。

如果添加了`virtual`，那么编译器会生成 vtable 虚函数表 与 vptr 虚表指针。`Base` 与 `Derived` 都会有一个虚函数表。表中存放着各自虚函数的地址（包括析构函数）。同时，每个对象补全在内存的最开始位置会多出一个隐藏指针 vptr,指向该对象所属类的 vtable。

在这个情况下，当编译器看到 delete ptr且析构函数是虚函数时。它不会像之前一样，直接调用指令，而是生成一段间接调用的逻辑：
+ 先读取ptr指向对象的内存首地址，得到vptr。
+ 通过 vptr 找到 vtable
+ 通过 vtable 找到析构函数实在存在的地址（由于该对象是 Derived，Derived 的 vptr 指向的是 Derived 的 vtable ，所以这里找到的就是 `Derived::~Derived()` 的地址）
+ 调用该析构函数 `Derived::~Derived()`
+ 释放内存空间

诶，这就结束了吗，基类不需要调用吗？是的，因为派生类的析构函数`Derived::~Derived()`的末尾会被编译器自动插入调用其父类析构函数`Base::~Base()`的指令。这里也可以解释：析构顺序是 Derived -> Base，先拆子，后拆父。









